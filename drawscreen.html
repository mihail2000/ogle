<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <script data-main="javascripts/drawmain" src="javascripts/require-jquery.js"></script>
    <script type="text/javascript" src="javascripts/jquery-ui-1.8.23.custom.min.js"></script>
    <script type="text/javascript" src="javascripts/kineticjs-4.0.1.js"></script>
    <link type="text/css" rel="Stylesheet" href="stylesheets/jquery-ui-1.8.23.custom.css">

    <style>
      body { background-color:#ffffff;}
      h2 { color:#11aa00; font-family:"Sans-serif", Verdana, Arial; font-weight:normal; }
      h3 { color:#11aa00; font-family:"Sans-serif", Verdana, Arial; font-weight:normal; }
      p { color:#000000; font-family:"Sans-serif", Verdana, Arial; line-height:50%; }
    </style>
    <script>      
      $(document).keydown(function(e) {
      if (e.keyCode === 8) {
          var element = e.target.nodeName.toLowerCase();
          if ((element != 'input' && element != 'textarea') || $(e.target).attr("readonly")) {
              return false;
          }
      }
    });
    </script>
   </head>
  <body onSelectStart="this.style.cursor='crosshair'; return false;"onMouseup="this.style.cursor='default'">
<script>
    
'use strict'
var TOOL_SELECT = 'select';
var TOOL_MOVE = 'move';
var TOOL_RECT = 'rect';
var TOOL_ARROW = 'arrow';
var TOOL_TEXT = 'settext';
var TOOL_ADDCHILD = 'addchild';
var TOOL_DELETE = 'delete';
var TOOL_LOAD = 'load';
var TOOL_SAVE = 'save';
var CONST_SEPARATOR = '<separator>';

var text_edit_shape = null;
var text_edit_string = '';
var add_child = null;

var statestartx = 200;

var cursorVisible = false;
var cursorTimerID = 0;

// Drop box handler
var dropbox_handler = {
  authenticated: false,
  client: null,
  file_data: '',
  /*
   * Authenticate establishes the connection to DropBox
   */ 
  Authenticate: function() {
      this.client = new Dropbox.Client({key: "WmTncw0VfBA=|nluPVTIPvryWoLLtlDSK1bTt8jZHOXIAfjhUZUVJGg==", sandbox: true});
      this.client.authDriver(new Dropbox.Drivers.Redirect({rememberUser: 'true'}));
      this.client.authenticate(function(error, client) {
        if (error) {
          return dropbox_handler.DropBoxError(error);
        }
      });
      
      this.authenticated = true;
  },
  /*
   * DropBoxError
   * DropBox error handling function
   */
  DropBoxError: function(error) {
      if (window.console) {  // Skip the "if" in node.js code.
        console.error(error);
      }
    
      switch (error.status) {

      case 401:
        // If you're using dropbox.js, the only cause behind this error is that
        // the user token expired.
        // Get the user through the authentication flow again.
        break;
    
      case 404:
        // The file or folder you tried to access is not in the user's Dropbox.
        // Handling this error is specific to your application.
        break;
    
      case 507:
        // The user is over their Dropbox quota.
        // Tell them their Dropbox is full. Refreshing the page won't help.
        break;
    
      case 503:
        // Too many API requests. Tell the user to try again later.
        // Long-term, optimize your code to use fewer API calls.
        break;
    
      case 400:  // Bad input parameter
      case 403:  // Bad OAuth request.
      case 405:  // Request method not expected
      default:
        // Caused by a bug in dropbox.js, in your application, or in Dropbox.
        // Tell the user an error occurred, ask them to refresh the page.
      }    
  },
  LoadContents: function(filename, callback) {
    var status = this.client.readFile(filename, callback);    
  },
  SaveContents: function(kineticLayer) {
    var writeToFile = XML_handler.get_header_XML();

    var shapes = kineticLayer.getChildren();
    for (var i = 0; i < shapes.length; i++)
    {
      var shape = shapes[i];      
      writeToFile += XML_handler.convert_to_XML(shape);
      //writeToFile += JSON.stringify(shapes[i]);
    }
    
    writeToFile += XML_handler.get_footer_XML();
    this.client.writeFile("jsmapper_2.xml", writeToFile, function(error, stat) {
        if (error) {
          return dropbox_handler.showError(error);  // Something went wrong.
        }  
    });
  }
};

// Menu object
var popup_menu = {
  items: ['Cut', 'Copy', 'Paste', CONST_SEPARATOR, 'Edit shape', 'Edit text', 'Delete'],
  visible: false,
  popup_menu_layer: null,
  selected_shape: null,
  selectMenuAction: function(menulayer, x, y) {
    if (this.selected_shape != null) {
      var selecteditem = selectShape(menulayer, x, y);
      this.hidePopup(menulayer);
      
      if (selecteditem != null) {
        
        switch (selecteditem.getText()) {
          case this.items[5]: // Edit text
            {
              changeText(this.selected_shape);
              break;
            }
          
          case this.items[6]: // Delete
            {
              layer.remove(this.selected_shape);
              layer.draw();
              break;
            }
          
        }
      }
      
    }
    
  },
  hidePopup: function(menulayer) {
      menulayer.removeChildren();
      menulayer.draw();
      this.visible = false;
  },
  showPopup: function(menulayer, item, x, y) {
    /*
     * show_popup
     *
     * Displays popup menu on given canvas coordinates.
     * Popup is used to manipulate selected objects (edit text, delete etc.)
     */
    
      if (this.visible) {
        this.hidePopup(menulayer);
      }
      
      this.visible = true;
      this.selected_shape = item;
      var y_index = 0;  
      
      for (var i = 0; i < this.items.length; i++) {
        var rect = null;
        
        if (this.items[i] != CONST_SEPARATOR) {
          rect = new Kinetic.Text({
          x: x,
          y: y + y_index,
          width: 100,
          height: 20,
          text: this.items[i],
          fill: '#cccccc',
          stroke: '#cccccc',
          fontSize: 8,
          fontFamily: 'Calibri',
          textFill: '#000',
          strokeWidth: 0.5,
          cornerRadius: 0,
          padding: 5,
          align: 'left',
          shadow: {
            color: 'gray',
            blur: 1,
            offset: [5, 5],
            opacity: 0.1
            }
          });
          y_index += 20;
        } else {
          rect = new Kinetic.Rect({
          x: x,
          y: y + y_index,
          width: 100,
          height: 3,
          fill: '#dddddd',
          stroke: '#dddddd',
          strokeWidth: 0.5,
          cornerRadius: 0,
          padding: 5,
          align: 'left',
          shadow: {
            color: 'gray',
            blur: 1,
            offset: [5, 5],
            opacity: 0.1
            }
          });
          y_index += 3;
          
        }
          menulayer.add(rect);

      }
      menulayer.draw();
    }
};

function toolSelection(toolSelected) {
  currentTool = toolSelected.val();

  switch (currentTool) {
    case TOOL_LOAD:
      {
        //loadFile('jsmapper_1.xml');
        break;
      }
    
    case TOOL_SAVE:
      {
        if (!dropbox_handler.authenticated) {
          dropbox_handler.Authenticate();
        }

        dropbox_handler.SaveContents(layer);
        break;
      }
    case TOOL_MOVE:
      {
        console.log('Drag Drop enabled');
        changeDragDrop(true);        
        break;
      }
    default:
      {
        console.log('Drag Drop disabled');
        changeDragDrop(false);
        break;
      }
  }
  
}

/*
window.onload = function() {

  
  var elem;
  if (document.getElementById && (elem = document.getElementById('container')) ) {
      if (elem.style) elem.style.cursor = 'crosshair';
  }

  dropbox_handler.Authenticate();
  
  var fileparameter = window.location.search.replace( "?filename=", "" );
  if (fileparameter != '') {
    loadFile(fileparameter);    
  }
  //dropbox_handler.LoadContents('jsmapper_1.xml');
  
}; //onload
*/
/*
function draw_element_handler(mainLayer, templayer) {
  
};
*/

function showCursor() {
  if (cursorVisible) {
    text_edit_shape.setText(text_edit_string);
    cursorVisible = false;
  } else {
    var newtext = text_edit_string + '|';
    text_edit_shape.setText(newtext);
    cursorVisible = true;
  }
  layer.draw(); 
}

function addChildNode(parent) {
  drawRectElement(layer, parent.getX() + 100, parent.getY() + 100, parent.getX() + 150, parent.getY() + 150);
  
  var line = new Kinetic.Line({
    points: [10, 10, 100, 100],
    stroke: "red",
    strokeWidth: 15,
    lineCap: "round",
    lineJoin: "round"
  });
  //var points = [parent.getX(), parent.getY(), parent.getX()+100, parent.getY()+100];
  //line.setPoints(points);
  line.moveTo(0, 0);
  layer.add(line);
  layer.draw();
}

function changeDragDrop(changeval) {
  var shapes = layer.getChildren();
  for (var i = 0; i < shapes.length; i++)
  {
    shapes[i].setDraggable(changeval);
  }
  
}

function changeText(shape) {
  
      // Select the shape user clicked / touched
    
  if (text_edit_shape == null) {
      text_edit_shape = shape;
      text_edit_string = '';

      text_edit_string = text_edit_shape.getText();

      // In non-touch environments, text is edited directly to the shape
      if (!Modernizr.touch) {
        cursorTimerID = setInterval(function(){showCursor()}, 500);                                
        text_edit_shape.setFill('#ffffff');
      // In touch environments, display text input box (TODO: figure out if there is more elegant way)
      } else {
        var newText = prompt('Enter new text', text_edit_shape.getText());
        text_edit_shape.setText(newText);
        text_edit_shape = null;
      }
  }
}

function keyDownHandler(event) {
  if (text_edit_shape != null) {
    switch (event.keyCode) {
      
      case 13: // enter
        {
          text_edit_shape.setText(text_edit_string);
          text_edit_shape.setFill('#aaaaaa');
          layer.draw();
          clearInterval(cursorTimerID); 
          text_edit_shape = null;                
          break;
        }
        
      case 8: // backspace
        {
          var currentString = text_edit_string;
          if (currentString.length > 1) {
            var newString = currentString.substr(0, currentString.length - 1);
            text_edit_string = newString;
            //text_edit_shape.draw();
          } else {
            text_edit_string = '';
          }
          text_edit_shape.setText(text_edit_string);
          layer.draw();                                 
          break;
        }

    default:
      {
        //text_edit_shape.setText('selected');
        var currentString = text_edit_string;              
        var character = String.fromCharCode(event.keyCode);
        var newString = currentString.concat(character);
        text_edit_string = newString.toLowerCase();
        text_edit_shape.setText(text_edit_string);
        //text_edit_shape.draw();
        layer.draw();
        break;
      }
    }
  }
}
    </script>
    
  </body>
</html>