<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <script data-main="javascripts/drawmain" src="javascripts/require-jquery.js"></script>
  
    <!-- 
  
    <script type="text/javascript" src="javascripts/jquery-1.8.0.min.js"></script>
    
    !-->
    <script type="text/javascript" src="javascripts/jquery-ui-1.8.23.custom.min.js"></script>
    <script type="text/javascript" src="javascripts/kineticjs-4.0.1.js"></script>
    <!-- 

    <script type="text/javascript" src="javascripts/modernizr.custom.90822.js"></script>
    <script type="text/javascript" src="javascripts/coffee-script.js"></script>
    <script type="text/javascript" src="javascripts/dropbox.js"></script> 
    <script type="text/javascript" src="javascripts/less.js"></script>    !-->
    <link type="text/css" rel="Stylesheet" href="stylesheets/jquery-ui-1.8.23.custom.css">

    <style>
      body { background-color:#ffffff;}
      h2 { color:#11aa00; font-family:"Sans-serif", Verdana, Arial; font-weight:normal; }
      h3 { color:#11aa00; font-family:"Sans-serif", Verdana, Arial; font-weight:normal; }
      p { color:#000000; font-family:"Sans-serif", Verdana, Arial; line-height:50%; }
    </style>
    <script>      
      $(document).keydown(function(e) {
      if (e.keyCode === 8) {
          var element = e.target.nodeName.toLowerCase();
          if ((element != 'input' && element != 'textarea') || $(e.target).attr("readonly")) {
              return false;
          }
      }
    });
    </script>
   </head>
  <body onSelectStart="this.style.cursor='not-allowed'; return false;"onMouseup="this.style.cursor='default'">
   <script>
    
'use strict'
var TOOL_SELECT = 'select';
var TOOL_MOVE = 'move';
var TOOL_RECT = 'rect';
var TOOL_ARROW = 'arrow';
var TOOL_TEXT = 'settext';
var TOOL_ADDCHILD = 'addchild';
var TOOL_DELETE = 'delete';
var TOOL_LOAD = 'load';
var TOOL_SAVE = 'save';
var CONST_SEPARATOR = '<separator>';

var text_edit_shape = null;
var text_edit_string = '';
var add_child = null;

var drawing = false;
var draw_start_x = 0;
var draw_start_y = 0;
var draw_end_x = 0;
var draw_end_y = 0;

var statestartx = 200;

var latestitem;
var currentTool = TOOL_RECT;

var cursorVisible = false;
var cursorTimerID = 0;

/*
 * XML_handler
 *
 * This class is used save diagrams as XML files and load diagrams from XML files.
 */
var XML_handler = {
  get_header_XML: function() {
    var str = '<?xml version="1.0" encoding="utf-8"?>\n<shapes>\n';
    return str;
  },
  get_footer_XML: function() {
    var str = '</shapes>';
    return str;
  },
  /*
   * convert_to_xml
   *
   * Converts given shape (1st paramerter) to XML string and returns it.
   * Returned XML can be used to save the given shape to a file.
   */
  convert_to_XML: function(shape) {
    var XMLString = '';
      var type = '';
      var CONST_TYPE_RECT = 'RECT';
      var CONST_TYPE_ARROW = 'ARROW';

      XMLString += '\t<shape ';

      if (shape instanceof Kinetic.Text) {
        type = CONST_TYPE_RECT;
        console.log('This is rect');
        XMLString += 'type="rect"';
      } else if (shape instanceof Kinetic.Line)
      {
        type = CONST_TYPE_ARROW;
        XMLString += 'type="arrow"';
        console.log('This is line');
      }
      
      switch (type)
      {
        case CONST_TYPE_RECT:
          {
            XMLString += this.XML_from_property(shape, 'getX', 'x')
            XMLString += this.XML_from_property(shape, 'getY', 'y')
            XMLString += this.XML_from_property(shape, 'getZIndex', 'zindex')
            XMLString += this.XML_from_property(shape, 'getHeight', 'height')
            XMLString += this.XML_from_property(shape, 'getWidth', 'width')
            XMLString += this.XML_from_property(shape, 'getCornerRadius', 'cornerradius')
            XMLString += this.XML_from_property(shape, 'getFill', 'fill')
            XMLString += '>';
            break;
          }
          
        case CONST_TYPE_ARROW:
          {
            //XMLString += this.XML_from_property(shape, 'getX', 'x')
            //XMLString += this.XML_from_property(shape, 'getY', 'y')
            var points = shape.getPoints();
              XMLString += this.XML_from_property(shape, 'getZIndex', 'zindex')
              XMLString += '>\n\t\t<coords>\n';
              
            for (var i = 0; i < points.length; i++)
            {
              XMLString += '\t\t\t<coord x="';  
              XMLString += points[i].x;
              XMLString += '" ';  
              XMLString += 'y="';  
              XMLString += points[i].y;
              XMLString += '"</coord>\n';  
            }
            XMLString += '\t\t</coords>\n\t';

            break;
          }
      }


      if (type === CONST_TYPE_RECT) {
        var txt = shape.getText();
        txt = txt.replace(/(^\s+|\s+$)/g,' ');
        if (txt != '') {
          XMLString += txt;
        }        
      }
      XMLString += '</shape>\n';
    return XMLString;
  },
  /*
   * XML_from_property
   *
   * Parameters:
   * obj - reference to the object (i.e. KineticJS shape type of object)
   * obj_property - name of the method to be called to retrieve the value from the given object
   * XMLAttribute - attribute name where to store the value from the given object
   *
   * Returns:
   * XML attribute with a given name and a value from the given object, using the given method.
   */
  XML_from_property: function(obj, obj_method, XMLAttribute, obj_property) {
    var str = ' ' + XMLAttribute;
    str += '="';
    if (obj_property === false || obj_property == undefined) {
      str += obj[obj_method]();      
    } else {
      str =+ obj[obj_property];
    }
    str += '"';
    return str;  
  }
  
};
// Drop box handler
var dropbox_handler = {
  authenticated: false,
  client: null,
  file_data: '',
  /*
   * Authenticate establishes the connection to DropBox
   */ 
  Authenticate: function() {
      this.client = new Dropbox.Client({key: "WmTncw0VfBA=|nluPVTIPvryWoLLtlDSK1bTt8jZHOXIAfjhUZUVJGg==", sandbox: true});
      this.client.authDriver(new Dropbox.Drivers.Redirect({rememberUser: 'true'}));
      this.client.authenticate(function(error, client) {
        if (error) {
          return dropbox_handler.DropBoxError(error);
        }
      });
      
      this.authenticated = true;
  },
  /*
   * DropBoxError
   * DropBox error handling function
   */
  DropBoxError: function(error) {
      if (window.console) {  // Skip the "if" in node.js code.
        console.error(error);
      }
    
      switch (error.status) {

      case 401:
        // If you're using dropbox.js, the only cause behind this error is that
        // the user token expired.
        // Get the user through the authentication flow again.
        break;
    
      case 404:
        // The file or folder you tried to access is not in the user's Dropbox.
        // Handling this error is specific to your application.
        break;
    
      case 507:
        // The user is over their Dropbox quota.
        // Tell them their Dropbox is full. Refreshing the page won't help.
        break;
    
      case 503:
        // Too many API requests. Tell the user to try again later.
        // Long-term, optimize your code to use fewer API calls.
        break;
    
      case 400:  // Bad input parameter
      case 403:  // Bad OAuth request.
      case 405:  // Request method not expected
      default:
        // Caused by a bug in dropbox.js, in your application, or in Dropbox.
        // Tell the user an error occurred, ask them to refresh the page.
      }    
  },
  LoadContents: function(filename, callback) {
    var status = this.client.readFile(filename, callback);    
  },
  SaveContents: function(kineticLayer) {
    var writeToFile = XML_handler.get_header_XML();

    var shapes = kineticLayer.getChildren();
    for (var i = 0; i < shapes.length; i++)
    {
      var shape = shapes[i];      
      writeToFile += XML_handler.convert_to_XML(shape);
      //writeToFile += JSON.stringify(shapes[i]);
    }
    
    writeToFile += XML_handler.get_footer_XML();
    this.client.writeFile("jsmapper_2.xml", writeToFile, function(error, stat) {
        if (error) {
          return dropbox_handler.showError(error);  // Something went wrong.
        }  
    });
  }
};

// Menu object
var popup_menu = {
  items: ['Cut', 'Copy', 'Paste', CONST_SEPARATOR, 'Edit shape', 'Edit text', 'Delete'],
  visible: false,
  popup_menu_layer: null,
  selected_shape: null,
  selectMenuAction: function(menulayer, x, y) {
    if (this.selected_shape != null) {
      var selecteditem = selectShape(menulayer, x, y);
      this.hidePopup(menulayer);
      
      if (selecteditem != null) {
        
        switch (selecteditem.getText()) {
          case this.items[5]: // Edit text
            {
              changeText(this.selected_shape);
              break;
            }
          
          case this.items[6]: // Delete
            {
              layer.remove(this.selected_shape);
              layer.draw();
              break;
            }
          
        }
      }
      
    }
    
  },
  hidePopup: function(menulayer) {
      menulayer.removeChildren();
      menulayer.draw();
      this.visible = false;
  },
  showPopup: function(menulayer, item, x, y) {
    /*
     * show_popup
     *
     * Displays popup menu on given canvas coordinates.
     * Popup is used to manipulate selected objects (edit text, delete etc.)
     */
    
      if (this.visible) {
        this.hidePopup(menulayer);
      }
      
      this.visible = true;
      this.selected_shape = item;
      var y_index = 0;  
      
      for (var i = 0; i < this.items.length; i++) {
        var rect = null;
        
        if (this.items[i] != CONST_SEPARATOR) {
          rect = new Kinetic.Text({
          x: x,
          y: y + y_index,
          width: 100,
          height: 20,
          text: this.items[i],
          fill: '#cccccc',
          stroke: '#cccccc',
          fontSize: 8,
          fontFamily: 'Calibri',
          textFill: '#000',
          strokeWidth: 0.5,
          cornerRadius: 0,
          padding: 5,
          align: 'left',
          shadow: {
            color: 'gray',
            blur: 1,
            offset: [5, 5],
            opacity: 0.1
            }
          });
          y_index += 20;
        } else {
          rect = new Kinetic.Rect({
          x: x,
          y: y + y_index,
          width: 100,
          height: 3,
          fill: '#dddddd',
          stroke: '#dddddd',
          strokeWidth: 0.5,
          cornerRadius: 0,
          padding: 5,
          align: 'left',
          shadow: {
            color: 'gray',
            blur: 1,
            offset: [5, 5],
            opacity: 0.1
            }
          });
          y_index += 3;
          
        }
          menulayer.add(rect);

      }
      menulayer.draw();
    }
};

function loadFile(filename) {
  dropbox_handler.LoadContents(filename, function(error, data) {
    $(data).find('shape').each(function () {
      switch ($(this).attr('type')) {
        case TOOL_RECT:
          {
            console.log('RECT');
            var x = parseInt($(this).attr('x'));
            var y = parseInt($(this).attr('y'));
            var width = parseInt($(this).attr('width'));
            var height = parseInt($(this).attr('height'));
            
            var text = '';
            if ($(this).text() != '') {
              text = $(this).text();
            }
  
            drawRectElement(layer, x, y, x + width, y + height, text);
            
            break;
          }
        
        case TOOL_ARROW:
          {
            console.log('ARROW');
            var points = [];
            
            $(this).find('coord').each(function () {
              points.push(parseInt($(this).attr('x')));
              points.push(parseInt($(this).attr('y')));
            });
            
            drawLineElement(layer, points);
            break;
          }
      }
    });  
  });
  
}

function toolSelection(toolSelected) {
  currentTool = toolSelected.val();

  switch (currentTool) {
    case TOOL_LOAD:
      {
        //loadFile('jsmapper_1.xml');
        break;
      }
    
    case TOOL_SAVE:
      {
        if (!dropbox_handler.authenticated) {
          dropbox_handler.Authenticate();
        }

        dropbox_handler.SaveContents(layer);
        break;
      }
    case TOOL_MOVE:
      {
        console.log('Drag Drop enabled');
        changeDragDrop(true);        
        break;
      }
    default:
      {
        console.log('Drag Drop disabled');
        changeDragDrop(false);
        break;
      }
  }
  
}

/*
window.onload = function() {

  
  var elem;
  if (document.getElementById && (elem = document.getElementById('container')) ) {
      if (elem.style) elem.style.cursor = 'crosshair';
  }

  dropbox_handler.Authenticate();
  
  var fileparameter = window.location.search.replace( "?filename=", "" );
  if (fileparameter != '') {
    loadFile(fileparameter);    
  }
  //dropbox_handler.LoadContents('jsmapper_1.xml');
  
}; //onload
*/
/*
function draw_element_handler(mainLayer, templayer) {
  
};
*/

function showCursor() {
  if (cursorVisible) {
    text_edit_shape.setText(text_edit_string);
    cursorVisible = false;
  } else {
    var newtext = text_edit_string + '|';
    text_edit_shape.setText(newtext);
    cursorVisible = true;
  }
  layer.draw(); 
}

function addChildNode(parent) {
  drawRectElement(layer, parent.getX() + 100, parent.getY() + 100, parent.getX() + 150, parent.getY() + 150);
  
  var line = new Kinetic.Line({
    points: [10, 10, 100, 100],
    stroke: "red",
    strokeWidth: 15,
    lineCap: "round",
    lineJoin: "round"
  });
  //var points = [parent.getX(), parent.getY(), parent.getX()+100, parent.getY()+100];
  //line.setPoints(points);
  line.moveTo(0, 0);
  layer.add(line);
  layer.draw();
}

function drawArrowElement(drawtolayer, x1, y1, x2, y2) {
  
  var points = [];
  
  points.push(x1);
  points.push(y1);
  points.push(x2);
  points.push(y2);
  
  drawLineElement(drawtolayer, points);
  
}

function drawLineElement(drawtolayer, points) {
  
  var x = 0;
  var y = 0;

  var arrow = new Kinetic.Line({
    points: points,
    stroke: "black",
    strokeWidth: 2
    });

  latestitem = arrow;

  // add the shape to the layer
  drawtolayer.add(arrow);
  drawtolayer.draw();

}

function drawSelectionElement(drawtolayer, startx, starty, endx, endy, text) {
  var rectx = 0;
  var recty = 0;
          
  var rectheight = 0;
  var rectwidth = 0;
          
  if (startx < endx) {
    rectx = startx;
    rectwidth = endx - startx;
  } else {
    rectx = endx;
    rectwidth = startx - endx;
  }
  
  if (starty < endy) {
    recty = starty;
    rectheight = endy - starty;
  } else {
    recty = endy;
    rectheight = starty - endy;
  }
  
  var rect = new Kinetic.Rect({

    x: rectx,
    y: recty,
    width: rectwidth,
    height: rectheight,
    fill: '#ffffff',
    stroke: 'black',
    textFill: '#555',
    strokeWidth: 1,
    cornerRadius: 0,
    padding: 0,
  });
  
  drawtolayer.add(rect);
  drawtolayer.draw();  
}

function drawRectElement(drawtolayer, startx, starty, endx, endy, text) {
  
  var rectx = 0;
  var recty = 0;
          
  var rectheight = 0;
  var rectwidth = 0;
          
  if (startx < endx) {
    rectx = startx;
    rectwidth = endx - startx;
  } else {
    rectx = endx;
    rectwidth = startx - endx;
  }
  
  if (starty < endy) {
    recty = starty;
    rectheight = endy - starty;
  } else {
    recty = endy;
    rectheight = starty - endy;
  }
  
  if (rectheight < 50) {
    rectheight = 50;              
  }

  if (rectwidth < 50) {
    rectwidth = 50;              
  }


  var rect = new Kinetic.Text({

    x: rectx,
    y: recty,
    width: rectwidth,
    height: rectheight,
    fill: '#aaaaaa',
    stroke: 'black',
    fontSize: 14,
    fontFamily: 'Calibri',
    textFill: '#555',
    strokeWidth: 1,
    cornerRadius: 10,
    padding: 20,
    align: 'center',
    shadow: {
      color: 'black',
      blur: 1,
      offset: [10, 10],
      opacity: 0.2
    }
  });
  
  if (text != '') {
    rect.setText(text);
  }
  latestitem = rect;

  // add the shape to the layer
  drawtolayer.add(rect);
  drawtolayer.draw();

}

function changeDragDrop(changeval) {
  var shapes = layer.getChildren();
  for (var i = 0; i < shapes.length; i++)
  {
    shapes[i].setDraggable(changeval);
  }
  
}

/*
 * selectShape
 *
 * Returns KineticJS shape object from the given layer, from the given coordinates
 */
function selectShape(selection_layer, x, y) {
  var shape = null;
  // Select the item user clicked
  var point = [x, y];
  var shapes = selection_layer.getIntersections(point);
  
  if (shapes.length > 0) {
    shape = shapes[0];  
  }
  
  for (var i=0; i < shapes.length; i++)
  {
    var newshape = shapes[i];
    
    if (shape.getZIndex() < newshape.getZIndex()) {
      shape = shapes[i];
    }
  }        
  
  return shape;
  
}

function changeText(shape) {
  
      // Select the shape user clicked / touched
    
  if (text_edit_shape == null) {
      text_edit_shape = shape;
      text_edit_string = '';

      text_edit_string = text_edit_shape.getText();

      // In non-touch environments, text is edited directly to the shape
      if (!Modernizr.touch) {
        cursorTimerID = setInterval(function(){showCursor()}, 500);                                
        text_edit_shape.setFill('#ffffff');
      // In touch environments, display text input box (TODO: figure out if there is more elegant way)
      } else {
        var newText = prompt('Enter new text', text_edit_shape.getText());
        text_edit_shape.setText(newText);
        text_edit_shape = null;
      }
  }
}

function getRelativeCoords(event) {
    if (event.offsetX !== undefined && event.offsetY !== undefined) { return { x: event.offsetX, y: event.offsetY }; }
    return { x: event.layerX, y: event.layerY };
}

/*
 * drawDownHandler
 *
 * This event is triggered when user presses mouse down on drawing canvas (non-touch) or when the touch event begins (touch).
 * Depending on the selected tool, user can draw new shapes, edit their texts, move them around etc.
 * This is where THE magic happens.
 */
function drawDownHandler(event) {
  
  var x = 0;
  var y = 0;
  
  if (Modernizr.touch) {
    x = event.pageX;
    y = event.pageY;          
  } else {
    var relativecoord = getRelativeCoords(event);
    x = relativecoord.x;
    y = relativecoord.y;          
  }
  
  console.log('Current Tool: ' + currentTool);
  
  switch (currentTool) {
    case TOOL_SELECT:
      {
        if (!popup_menu.visible) {
          var item = selectShape(layer, x, y);
          if (item != null) {
            popup_menu.showPopup(popup_menu_layer, item, x, y);          
          } else {
            console.log('hide popup');
            popup_menu.hidePopup(popup_menu_layer);
          }
        } else {
          popup_menu.selectMenuAction(popup_menu_layer, x, y);
        }
        break;
      }
    
    case TOOL_ARROW:
    case TOOL_RECT:
      {
        popup_menu.hidePopup(popup_menu_layer);
        drawing = true;
        draw_start_x = x;
        draw_start_y = y;              
        break;
      }
    
    case TOOL_TEXT: // Change text of the selected shape
      {
        popup_menu.hidePopup(popup_menu_layer);
        changeText(selectShape(layer, x, y));
        break;
      }
    case TOOL_ADDCHILD:
      {
        popup_menu.hidePopup(popup_menu_layer);
        add_child = selectShape(layer, x, y);
        
        if (add_child != null){
          addChildNode(add_child);
        }
        
        break;
      }
    
    case TOOL_DELETE:
      {
        popup_menu.hidePopup(popup_menu_layer);
        var itemToDelete = selectShape(layer, x, y);
        
        if (itemToDelete != null) {
          layer.remove(itemToDelete);
          layer.draw();
          itemToDelete = null;
        }
        break;
      }
      
    default:
    {
      popup_menu.hidePopup(popup_menu_layer);
      break;
    }
  }
}

function drawEndHandler(event) {        

  if (drawing) {
    if (!Modernizr.touch) {
      var relativecoord = getRelativeCoords(event);
      draw_end_x = relativecoord.x;
      draw_end_y = relativecoord.y;  
    } 

    switch (currentTool) {
      case TOOL_ARROW:
      {
        templayer.removeChildren();
        templayer.draw();
        drawing = false;
        drawArrowElement(layer, draw_start_x, draw_start_y, draw_end_x, draw_end_y);
        break;    
      }
      case TOOL_RECT:
      {
        templayer.removeChildren();
        templayer.draw();
        drawing = false;
        drawRectElement(layer, draw_start_x, draw_start_y, draw_end_x, draw_end_y);          
        break;      
      }
    }
  }
}

function drawMoveHandler(event) {
  
  var x = 0;
  var y = 0;
  
  if (Modernizr.touch) {
    x = event.pageX;
    y = event.pageY;          
  } else {
    var relativecoord = getRelativeCoords(event);
    x = relativecoord.x;
    y = relativecoord.y;  
  }
  
  if (currentTool === TOOL_MOVE) {
      
        console.log("I am here");

        if (!Modernizr.touch) {
          var item = selectShape(layer, x, y);
          // if the cursor is currently hovering on top
          if (item != null) {
            templayer.removeChildren();
            var CONST_SELECTION_ITEM_SIZE = 4;
            drawSelectionElement(templayer, item.getX() + (item.getWidth() / 2) - CONST_SELECTION_ITEM_SIZE, item.getY() - CONST_SELECTION_ITEM_SIZE, item.getX() + (item.getWidth() / 2) + CONST_SELECTION_ITEM_SIZE, item.getY() + CONST_SELECTION_ITEM_SIZE);
            drawSelectionElement(templayer, item.getX() - CONST_SELECTION_ITEM_SIZE, item.getY() + (item.getHeight() / 2) - CONST_SELECTION_ITEM_SIZE, item.getX() + CONST_SELECTION_ITEM_SIZE,item.getY() + (item.getHeight() / 2) + CONST_SELECTION_ITEM_SIZE);
            drawSelectionElement(templayer, item.getX() + (item.getWidth() / 2) - CONST_SELECTION_ITEM_SIZE, item.getY() - CONST_SELECTION_ITEM_SIZE + item.getHeight(), item.getX() + (item.getWidth() / 2) + CONST_SELECTION_ITEM_SIZE, item.getY() + CONST_SELECTION_ITEM_SIZE + item.getHeight());
            drawSelectionElement(templayer, item.getX() - CONST_SELECTION_ITEM_SIZE + item.getWidth(), item.getY() + (item.getHeight() / 2) - CONST_SELECTION_ITEM_SIZE, item.getX() + CONST_SELECTION_ITEM_SIZE + item.getWidth(), item.getY() + (item.getHeight() / 2) + CONST_SELECTION_ITEM_SIZE);

            drawSelectionElement(templayer, item.getX() - CONST_SELECTION_ITEM_SIZE, item.getY() - CONST_SELECTION_ITEM_SIZE, item.getX() + CONST_SELECTION_ITEM_SIZE, item.getY() + CONST_SELECTION_ITEM_SIZE);
            drawSelectionElement(templayer, item.getX() + item.getWidth() - CONST_SELECTION_ITEM_SIZE, item.getY() - CONST_SELECTION_ITEM_SIZE, item.getX() + item.getWidth() + CONST_SELECTION_ITEM_SIZE, item.getY() + CONST_SELECTION_ITEM_SIZE);
            drawSelectionElement(templayer, item.getX() - CONST_SELECTION_ITEM_SIZE, item.getY() + item.getHeight() - CONST_SELECTION_ITEM_SIZE, item.getX() + CONST_SELECTION_ITEM_SIZE, item.getY() + item.getHeight() + CONST_SELECTION_ITEM_SIZE);
            drawSelectionElement(templayer, item.getX() + item.getWidth() - CONST_SELECTION_ITEM_SIZE, item.getY() + item.getHeight() - CONST_SELECTION_ITEM_SIZE, item.getX() + item.getWidth() + CONST_SELECTION_ITEM_SIZE, item.getY() + item.getHeight() + CONST_SELECTION_ITEM_SIZE);
            
          } else {
            templayer.removeChildren();
            templayer.draw();
          }
        }
        
  }

  
  
  if (drawing === true) {
    draw_end_x = x;
    draw_end_y = y;
    templayer.removeChildren();
    templayer.draw();
    
    switch (currentTool) {
      case TOOL_ARROW:
        {
          drawArrowElement(templayer, draw_start_x, draw_start_y, x, y);
          break;
        }
      
      case TOOL_RECT:
        {
          drawRectElement(templayer, draw_start_x, draw_start_y, x, y);                    
          break;
        }        
    }
    
  }
}

function keyDownHandler(event) {
  if (text_edit_shape != null) {
    switch (event.keyCode) {
      
      case 13: // enter
        {
          text_edit_shape.setText(text_edit_string);
          text_edit_shape.setFill('#aaaaaa');
          layer.draw();
          clearInterval(cursorTimerID); 
          text_edit_shape = null;                
          break;
        }
        
      case 8: // backspace
        {
          var currentString = text_edit_string;
          if (currentString.length > 1) {
            var newString = currentString.substr(0, currentString.length - 1);
            text_edit_string = newString;
            //text_edit_shape.draw();
          } else {
            text_edit_string = '';
          }
          text_edit_shape.setText(text_edit_string);
          layer.draw();                                 
          break;
        }

    default:
      {
        //text_edit_shape.setText('selected');
        var currentString = text_edit_string;              
        var character = String.fromCharCode(event.keyCode);
        var newString = currentString.concat(character);
        text_edit_string = newString.toLowerCase();
        text_edit_shape.setText(text_edit_string);
        //text_edit_shape.draw();
        layer.draw();
        break;
      }
    }
  }
}
var el = document.getElementById('container');

/*
if (Modernizr.touch) {
  el.addEventListener('touchstart', function(event) { drawDownHandler(event); });    
  el.addEventListener('touchend', function(event) { drawEndHandler(event); });    
  el.addEventListener('touchmove', function(event) { drawMoveHandler(event); });    
} else {
  el.addEventListener('mousedown', function(event) { drawDownHandler(event); });    
  el.addEventListener('mouseup', function(event) { drawEndHandler(event); });    
  el.addEventListener('mousemove', function(event) { drawMoveHandler(event); });    
}
document.addEventListener('keydown', function(event) { keyDownHandler(event); });
*/
    </script>
    
  </body>
</html>